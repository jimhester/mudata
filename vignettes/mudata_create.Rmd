---
title: "Creating mudata objects"
author: "Dewey Dunnington"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{mudata_create}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

Objects are created using the `mudata()` function, which takes a data frame/tibble with columns (at least) `param` and `value`. If you have more than one location, you will need a `location` column, and if you have points measured at more than one time, you'll need a column that describes the point in time (probably called `date` or `datetime`, or if you're a [paleolimnologist](https://www.wikipedia.org/wiki/Paleolimnology) like me, `depth` and/or `age`).

As an example, we'll use a small subset of data from two cores I collected a long time ago:

```{r, include = FALSE}
library(mudata2)
pocmajsum <- tibble::as_tibble(pocmajsum)
```

```{r, message=FALSE}
library(mudata2)
library(tidyverse)
poc_maj <- pocmajsum %>%
  select(core, depth, Ca, Ti, V)
poc_maj
```

Here, `depth` is the depth in the core, and `Ca`, `Ti`, and `V` are elemental concentrations in the sediment. To get this into parameter-long format, we need to use the `gather()` function in the **tidyr** package, and rename the `core` column to `location`.

```{r}
poc_maj_long <- poc_maj %>%
  gather(Ca, Ti, V, key = "param", value = "value") %>%
  rename(location = core)
poc_maj_long
```

This is the form of data needed by the `mudata()` constructor.

```{r poc-maj}
poc_maj_md <- mudata(poc_maj_long)
autoplot(poc_maj_md, y = "depth") + scale_y_reverse()
```

## Old readme:

Creating a `mudata` object from your own data is slightly more difficult, but the package contains a few functions to (hopefully) make things a bit easier. The key is creating the `$data` table in the correct format; the rest can be handled automatically by the `mudata()` constructor.

### Case 1: Wide, summarised data

Probably the most common case, wide, summarised data is the norm in most disciplines. If you've gotten this far, there is a good chance that you have data like this hanging around somewhere:

```{r}
data("pocmajsum")
pocmajwide <- pocmajsum %>%
  select(core, depth, Ca, V, Ti)
```

```{r, echo=FALSE}
knitr::kable(pocmajwide, row.names = FALSE, digits = 0)
```

This is a small subset of paleolimnological data for two sediment cores near Halifax, Nova Scotia. The data is a multi-parameter spatiotemporal dataset because it contains multiple parameters (calcium, titanium, and vanadium concentrations) measured along a common axis (depth in the sediment core) at discrete locations (cores named MAJ-1 and POC-2). Currently, our columns are not named properly: for the `mudata` format the terminology is 'location' not 'core'. The `rename()` function in `dplyr` does all the work here, easily renaming columns in place.

```{r}
pocmajwide <- pocmajwide %>%
  rename(location = core)
```

Finally, we need to get the data into a "long" format, with a column named "param" and our actual values in a single column (called "value", predictably). This can be done using the `gather()` function in the [tidyr](https://cran.r-project.org/package=tidyr) package.

```{r, warning=FALSE}
library(tidyr)
pocmajlong <- pocmajwide %>%
  gather(Ca, Ti, V, key = "param", value = "value")
```

The (first six rows of the) data now look like this:

```{r, echo=FALSE}
knitr::kable(head(pocmajlong), row.names = FALSE, digits=0)
```

The last important thing to consider is the axis on which the data are aligned. This sounds complicated but isn't: these axes are the same axes you might use to plot the data, in this case `depth`. The `mudata()` constructor needs to know which column this is, either by explicitly passing `x_columns = "depth"` or by placing the column between "param" and "value". In most cases (like this one) it can be guessed (you'll see a message telling you which columns were assigned this value).

Now the data is ready to be put into the `mudata()` constructor. If it isn't, the constructor will throw an error (hopefully) telling you how to fix the data.

```{r}
md <- mudata(pocmajlong)
autoplot(md, y="depth") + scale_y_reverse()
```

### Case 2: Wide, summarised data with uncertainty

Data is often output in a format similar to the format above, but with uncertainty information in paired columns. Data from an ICP-MS, for example is often in this format, with the concentration and a +/- column next to it. One of the advantages of a long format is the ability to include this information in a way that makes plotting with error bars easy. The `pocmajsum` dataset is a version of the dataset described above, but with standard deviation values in paired columns with the value itself.

```{r}
data("pocmajsum")
```

```{r, echo=FALSE}
knitr::kable(pocmajsum, row.names = FALSE, digits = 0)
```

As above, we need to rename the "core" and column to "location" using the `rename()` function (from `dplyr`).

```{r}
pocmajwide <- pocmajsum %>%
  rename(location = core)
```

Then (also as above), we need to "melt" the data to get it into long form. Because we have paired columns, this is handled by a different function (from the mudata package) called `parallel_melt()`.

```{r}
pocmajlong <- parallel_gather(pocmajwide, key = "param",
                              value=c(Ca, Ti, V), 
                              sd=c(Ca_sd, Ti_sd, V_sd))
```

```{r, echo=FALSE}
knitr::kable(head(pocmajlong), row.names = FALSE, digits=0)
```

The data is now ready to be fed to the `mudata()` constructor, after which we can use the `plot()` function to add error bars based on the `sd` column.

```{r, warning=FALSE}
md <- mudata(pocmajlong)
autoplot(md, y="depth", error_var="sd") + scale_y_reverse()
```
